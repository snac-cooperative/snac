#!/usr/bin/env php
<?php
/**
 * Refresh the Elatic Search Indices
 *
 * This script is more "dirty" to be efficient in rebuilding the Elastic Search index.  It queries
 * the postgres database directly to get required information to build the elastic search indices.
 *
 * It fills two indices by default: the base search index for UI interaction and the all names index
 * for identity reconciliation.
 *
 * @author Robbie Hott
 * @license http://opensource.org/licenses/BSD-3-Clause BSD 3-Clause
 * @copyright 2015 the Rector and Visitors of the University of Virginia, and
 *            the Regents of the University of California
 */
// Include the global autoloader generated by composer
include "../vendor/autoload.php";

use \Monolog\Logger;
use \Monolog\Handler\StreamHandler;

// Set up the global log stream
$log = new StreamHandler("rebuild_browse_index.log", Logger::DEBUG);

// SNAC Postgres DB Connector
$db = new \snac\server\database\DatabaseConnector();

$primaryCount = 0;
$primaryStart = false;
$primaryBody = array();

$counts = array();

echo "Querying the relation degrees from the database.\n";

$allRelCount = $db->query("select a.ic_id, count(*) as degree from
            (select r.id, r.ic_id from
                related_identity r,
                (select distinct id, max(version) as version from related_identity group by id) a
                where a.id = r.id and a.version = r.version and not r.is_deleted) a
                group by ic_id", array());
while($c = $db->fetchrow($allRelCount))
{
    $counts[$c["ic_id"]] = array();
    $counts[$c["ic_id"]]["degree"] = $c["degree"];
}

echo "Querying the resource relation degrees from the database.\n";

$allRelCount = $db->query("select a.ic_id, count(*) as degree from
            (select r.id, r.ic_id from
                related_resource r,
                (select distinct id, max(version) as version from related_resource group by id) a
                where a.id = r.id and a.version = r.version and not r.is_deleted) a
                group by ic_id", array());
while($c = $db->fetchrow($allRelCount))
{
    $counts[$c["ic_id"]]["resources"] = $c["degree"];
}


$previousICID = -1;


echo "Querying the names from the database.\n";

$allNames = $db->query("select one.ic_id, one.version, one.ark_id, two.id as name_id, two.original, two.preference_score, one.entity_type from
    (select
        aa.is_deleted,aa.id,aa.version, aa.ic_id, aa.original, aa.preference_score
    from
        name as aa,
        (select name.id,max(name.version) as version from name
            left join (select v.id as ic_id, v.version, nrd.ark_id
                    from version_history v
                    left join (select bb.id, max(bb.version) as version from
                    (select id, version from version_history where status in ('published', 'deleted', 'tombstone')) bb
                    group by id order by id asc) mv
                    on v.id = mv.id and v.version = mv.version
                    left join nrd on v.id = nrd.ic_id
                    where
                    v.status = 'published'
                    order by v.id asc, v.version desc) vh
                on name.version<=vh.version and
                name.ic_id=vh.ic_id
            group by name.id) as bb
    where
        aa.id = bb.id and
        not aa.is_deleted and
        aa.version = bb.version
    order by ic_id asc, preference_score desc, id asc) two,
    (select v.id as ic_id, v.version, n.ark_id, etv.value as entity_type
    from
        version_history v,
        (select bb.id, max(bb.version) as version from
            (select id, version from version_history where status in ('published', 'deleted', 'tombstone')) bb
            group by id order by id asc) mv,
        vocabulary etv,
        nrd n
    where
        v.id = mv.id and
        v.version = mv.version and
        v.status = 'published' and
        v.id = n.ic_id and
        n.ark_id is not null and
        n.entity_type = etv.id) one
where
    two.ic_id = one.ic_id
order by
    one.ic_id asc, two.preference_score desc, two.id asc;", array());



$db->prepare("insert_index", "insert into name_index (ic_id, ark, entity_type, name_entry, name_entry_lower, degree, resources) values
                ($1, $2, $3, $4, lower($4), $5, $6);");

echo "Updating the Postgres name indices. This may take a while...\n";
while($name = $db->fetchrow($allNames))
{
    // The data is ordered by ic_id and then preference score.  We will currently say the preferred name
    // is the one with the highest preference score for each ic_id.  So, if we haven't ever seen this ic_id
    // before, this is the preferred name entry for this ic.
    if (isset($counts[$name["ic_id"]]) && isset($counts[$name["ic_id"]]["degree"])) {
        $name["degree"] = (int) $counts[$name["ic_id"]]["degree"];
    } else {
        $name["degree"] = 0;
    }
    if (isset($counts[$name["ic_id"]]) && isset($counts[$name["ic_id"]]["resources"])) {
        $name["resources"] = (int) $counts[$name["ic_id"]]["resources"];
    } else {
        $name["resources"] = 0;
    }

    if ($previousICID != $name["ic_id"]) {
        indexMain($name["original"], $name["ark_id"], (int) $name["ic_id"], $name["entity_type"], $name["degree"], $name["resources"]);
    }
    $previousICID = $name["ic_id"];
}


echo "Done\n";


function indexMain($nameText, $ark, $icid, $entityType, $degree, $resources) {
    global $db;
    // Insert into the Postgres Index

    $db->execute("insert_index", array($icid, $ark, $entityType, $nameText, $degree, $resources));
}


