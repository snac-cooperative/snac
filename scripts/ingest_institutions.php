#!/usr/bin/env php
<?php
/**
 * Bulk ingest of ARKs given in text input file
 *
 * Given a list of ARKs as input, this script converts them to Constellation objects, and also
 * gets the list of all their Constellation Relation links and imports them.  Then, it sets up the original set's
 * Constellation Relations appropriately inside snac.
 *
 * @author Robbie Hott
 * @license http://opensource.org/licenses/BSD-3-Clause BSD 3-Clause
 * @copyright 2015 the Rector and Visitors of the University of Virginia, and
 *            the Regents of the University of California
 */
// Include the global autoloader generated by composer
include "../vendor/autoload.php";

use \Monolog\Logger;
use \Monolog\Handler\StreamHandler;

// Set up the global log stream
$log = new StreamHandler(\snac\Config::$LOG_DIR . \snac\Config::$SERVER_LOGFILE, Logger::DEBUG);

// Did we parse a file?
$parsedFile = false;

// SNAC Postgres DB Handler
$dbu = new snac\server\database\DBUtil();

// SNAC Postgres User Handler
$dbuser = new \snac\server\database\DBUser();
$tempUser = new \snac\data\User();
$tempUser->setUserName("system@localhost");
$user = $dbuser->readUser($tempUser);
$user->generateTemporarySession();

// ElasticSearch Handler
$eSearch = null;
if (\snac\Config::$USE_ELASTIC_SEARCH) {
    $eSearch = Elasticsearch\ClientBuilder::create()
        ->setHosts([\snac\Config::$ELASTIC_SEARCH_URI])
        ->setRetries(0)
        ->build();
}

// Create new parser
$e = new \snac\util\EACCPFParser();
$e->setConstellationOperation("insert");
printf("Done creating new parser.\n");

$line = file($argv[2], FILE_IGNORE_NEW_LINES);

$seenArks = array();

foreach ($line as $data) {
    list ($ark, $junk) = explode(",",$data);

    // Create a full path file name
    //$filename = $argv[1]."/$short_file";
    list($junk, $parts) = explode("ark:/", $ark);
    list($first, $second) = explode("/", $parts);
    $filename = $argv[1] . "/" . $first . "-" . $second . ".xml";

    $parsedFile = true;

    // Print out a message stating that this file is being parsed
    echo "Parsing: $filename\n";

    $constellation = $e->parseFile($filename);

    // Make sure it isn't already in the database
    $check = $dbu->readPublishedConstellationByARK($constellation->getArk(), true);

    $written = null;
    if ($check !== false) {
        echo "  Using existing constellation\n";
        $written = $dbu->readConstellation($check->getID());
    } else {
        // Write the constellation to the DB
        echo "  Writing new constellation\n";
        $written = $dbu->writeConstellation($user,
                                            $constellation,
                                            "bulk ingest of merged",
                                            'ingest cpf');

        // Update it to be published
        $dbu->writeConstellationStatus($user, $written->getID(), "published");
        // index ES
        indexESearch($written);

        // If this is published, then it should point to itself in the lookup table.
        $selfDirect = array($written);
        $dbu->updateConstellationLookup($written, $selfDirect);

    }

    /*
     * Add to the snac_institution table. An institution is a constellation, usually in summary form. The
     * institution code only cares about the constellation ID aka ic_id, from getID().
     */
    $dbuser->writeInstitution($written);
    printf("Added to table snac_institutions: %s (ARK: %s)\n", $written->getID(), $written->getArk());


    $seenArks[$written->getID()] = $written->getArk();
}


// If no file was parsed, then print the output that something went wrong
if ($parsedFile == false) {
    echo "No arks given\n\n"
        . "Sample usage: ./ingest_institutions.php /data/merge list.txt\n\n";
}

/**
 * @param \snac\data\Constellation $written
 */
function indexESearch($written) {
    global $eSearch;
    if ($eSearch != null) {
        $params = [
            'index' => \snac\Config::$ELASTIC_SEARCH_BASE_INDEX,
            // 'type' => \snac\Config::$ELASTIC_SEARCH_BASE_TYPE,
            'id' => $written->getID(),
            'body' => [
                'nameEntry' => $written->getPreferredNameEntry()->getOriginal(),
                    'entityType' => $written->getEntityType()->getID(),
                    'arkID' => $written->getArk(),
                    'id' => $written->getID(),
                    'degree' => count($written->getRelations()),
                    'timestamp' => date("c")
                ]
            ];

        $eSearch->index($params);
    }
}
