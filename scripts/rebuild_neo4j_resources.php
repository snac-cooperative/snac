#!/usr/bin/env php
<?php
/**
 * Refresh the Elatic Search Indices
 *
 * This script is more "dirty" to be efficient in rebuilding the Elastic Search index.  It queries
 * the postgres database directly to get required information to build the elastic search indices.
 *
 * It fills two indices by default: the base search index for UI interaction and the all names index
 * for identity reconciliation.
 *
 * @author Robbie Hott
 * @license http://opensource.org/licenses/BSD-3-Clause BSD 3-Clause
 * @copyright 2015 the Rector and Visitors of the University of Virginia, and
 *            the Regents of the University of California
 */
// Include the global autoloader generated by composer
include "../vendor/autoload.php";

use \Monolog\Logger;
use \Monolog\Handler\StreamHandler;

// Set up the global log stream
$log = new StreamHandler(\snac\Config::$LOG_DIR . \snac\Config::$SERVER_LOGFILE, Logger::DEBUG);

// SNAC Postgres DB Connector
$db = new \snac\server\database\DatabaseConnector();

$primaryCount = 0;
$secondaryCount = 0;
$primaryStart = false;
$secondaryStart = false;
$primaryBody = array();
$secondaryBody = array();

$rels = array();

$lookup = [
    "document_type" => [],
    "document_role" => []
];

$connector = null;

if (\snac\Config::$USE_NEO4J) {
    $connector = \GraphAware\Neo4j\Client\ClientBuilder::create()
        ->addConnection('bolt', \snac\Config::$NEO4J_BOLT_URI)
        ->build();
}

if ($connector == null)
    die("Could not connect to Neo4J");

echo "Querying the vocabulary from the database.\n";

$result = $db->query("select * from vocabulary where type = 'document_type';", array());
while($row = $db->fetchrow($result))
{
    $lookup["document_type"][$row["id"]] = [
        "uri" => $row["uri"],
        "value" => $row["value"]
    ];
}

$result = $db->query("select * from vocabulary where type = 'document_role';", array());
while($row = $db->fetchrow($result))
{
    $lookup["document_role"][$row["id"]] = [
        "uri" => $row["uri"],
        "value" => $row["value"]
    ];
}


echo "Querying the resource relations from the database.\n";

$allRel = $db->query("select r.id, r.ic_id, r.version, r.resource_id, r.resource_version, r.role as type, r.arcrole as relation from
                related_resource r,
                (select distinct id, max(version) as version from related_resource group by id) a
                where a.id = r.id and a.version = r.version and not r.is_deleted", array());
while($row = $db->fetchrow($allRel))
{
    $rels[$row["id"]] = [
        "id" => $row["id"],
        "version" => $row["version"],
        "source" => $row["ic_id"],
        "target" => $row["resource_id"],
        "relation" => isset($lookup["document_role"][$row["relation"]]) ? $lookup["document_role"][$row["relation"]]["value"] : null
    ];
}

$previousICID = -1;

echo "Querying the resources from the database.\n";

$allNames = $db->query("select b.id, b.version, b.title, b.display_entry, b.href, b.type
                        from resource_cache b,
                        (select distinct id, max(version) as version from resource_cache group by id) a
                        where b.id = a.id and b.version = a.version and not b.is_deleted", array());
$nodes = array();
while($name = $db->fetchrow($allNames))
{
        $nodes[$name["id"]] = [
            "id" => $name["id"],
            "version" => $name["version"],
            "href" => $name["href"],
            "type" => isset($lookup["document_type"][$row["type"]]) ? $lookup["document_type"][$row["type"]]["value"] : null,
            "title" => $name["title"],
            "display_entry" => $name["display_entry"]
        ];
}

echo "Updating the Neo4J Graph. This may take a while...\n";

$stack = $connector->stack();
$i = 0;
foreach ($nodes as $node) {
    $stack->push('CREATE (n:Resource) SET n += {infos}',
        [
            'infos' => $node
        ]);
    if ($i++ > 10000) {
        $txn = $connector->transaction();
        $txn->runStack($stack);
        $txn->commit();
        $stack = $connector->stack();
        echo "Committed $i nodes\n";
        $i = 0;
    }

}
$txn = $connector->transaction();
$txn->runStack($stack);
$txn->commit();

$connector->run('CREATE CONSTRAINT ON (r:Resource) ASSERT r.id IS UNIQUE');

$stack = $connector->stack();
$i = 0;
foreach ($rels as $edge) {
    $stack->push("MATCH (a:Identity {id: {id1} }),(b:Resource {id: {id2} })
        CREATE (a)-[r:RRELATION {infos}]->(b)",
        [
            'id1' => $edge["source"],
            'id2' => $edge["target"],
            'infos' => [
                "role" => $edge["relation"],
                "id" => $edge["id"],
                "version" => $edge["version"]
            ]
        ]);
    if ($i++ > 1000) {
        $txn = $connector->transaction();
        $txn->runStack($stack);
        $txn->commit();
        $stack = $connector->stack();
        echo "Committed $i edges\n";
        $i = 0;
    }
}
$txn = $connector->transaction();
$txn->runStack($stack);
$txn->commit();
